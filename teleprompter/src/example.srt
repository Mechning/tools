1
00:00:00,000 --> 00:00:03,405
>> Hello everyone, and
welcome to today's webinar.

2
00:00:03,405 --> 00:00:07,455
Before we begin, we want to
cover a few housekeeping items.

3
00:00:07,455 --> 00:00:09,435
For any common technical issues,

4
00:00:09,435 --> 00:00:10,860
please refer to the Help widget

5
00:00:10,860 --> 00:00:12,840
located at the bottom of your screen.

6
00:00:12,840 --> 00:00:15,210
This webinar was pre-recorded and

7
00:00:15,210 --> 00:00:17,565
is being presented with a live Q&A.

8
00:00:17,565 --> 00:00:19,800
If you're tuning in for
the initial webcast,

9
00:00:19,800 --> 00:00:21,060
you can submit questions via

10
00:00:21,060 --> 00:00:23,655
the Q&A widget on the
left side of your screen.

11
00:00:23,655 --> 00:00:25,440
The researchers will
be answering them

12
00:00:25,440 --> 00:00:27,450
via the widget in real time.

13
00:00:27,450 --> 00:00:31,350
Also stick around after the
webinar for the live Q&A,

14
00:00:31,350 --> 00:00:35,220
when the researchers will dive
deeper on popular questions asked.

15
00:00:35,220 --> 00:00:37,650
Additional resources
and links provided from

16
00:00:37,650 --> 00:00:39,690
today's presentation can be found in

17
00:00:39,690 --> 00:00:42,375
the resource list on the
right side of your screen.

18
00:00:42,375 --> 00:00:44,780
An on-demand version
of the webinar will

19
00:00:44,780 --> 00:00:46,730
be available approximately
one day after

20
00:00:46,730 --> 00:00:48,620
the initial webcast and can be

21
00:00:48,620 --> 00:00:50,360
accessed using the same audience link

22
00:00:50,360 --> 00:00:51,865
that was sent to you earlier.

23
00:00:51,865 --> 00:00:53,660
On-demand viewers will get to hear

24
00:00:53,660 --> 00:00:55,745
the recorded version of the live Q&A.

25
00:00:55,745 --> 00:00:58,110
Enjoy the webinar.

26
00:01:03,680 --> 00:01:06,325
>> Hi, I'm Chris Lovett,

27
00:01:06,325 --> 00:01:09,140
and I work in the Microsoft
Research Lab in Redmond.

28
00:01:09,140 --> 00:01:11,240
In this webinar, I'll explain

29
00:01:11,240 --> 00:01:15,230
the Coyote project and walk
through some example code.

30
00:01:15,230 --> 00:01:17,540
Coyote is a .NET Framework and

31
00:01:17,540 --> 00:01:19,850
testing tool that can help
you solve problems with

32
00:01:19,850 --> 00:01:23,090
concurrency and non-determinism in

33
00:01:23,090 --> 00:01:25,295
the state machinery of your code.

34
00:01:25,295 --> 00:01:29,630
This project is brought to
you by these three people:

35
00:01:29,630 --> 00:01:35,555
Pantazis and Akash, and the
code is available on GitHub.

36
00:01:35,555 --> 00:01:38,090
Software developers are struggling to

37
00:01:38,090 --> 00:01:40,625
manage the complexity of their code,

38
00:01:40,625 --> 00:01:45,300
especially as things are becoming
more and more asynchronous.

39
00:01:45,670 --> 00:01:49,415
Also, as we move into the
world of microservices,

40
00:01:49,415 --> 00:01:51,170
engineers are being
asked to ship more

41
00:01:51,170 --> 00:01:55,465
frequently in a world that is
more and more distributed.

42
00:01:55,465 --> 00:02:00,155
At the same time, this
complexity results in more bugs.

43
00:02:00,155 --> 00:02:02,705
As businesses, including Microsoft,

44
00:02:02,705 --> 00:02:05,870
deliver more of their mission
critical systems in the Cloud,

45
00:02:05,870 --> 00:02:10,175
bugs in this code result
in serious revenue loss.

46
00:02:10,175 --> 00:02:14,030
So this makes it even more critical
that we do everything we can

47
00:02:14,030 --> 00:02:18,875
to improve the state of the art
for engineering these systems.

48
00:02:18,875 --> 00:02:22,490
Coyote guides developers
into building rock solid,

49
00:02:22,490 --> 00:02:26,070
highly parallel code.
Let me illustrate.

50
00:02:28,360 --> 00:02:31,460
This animation shows messages passing

51
00:02:31,460 --> 00:02:34,340
through a highly parallel
distributed system.

52
00:02:34,340 --> 00:02:36,560
Each node represents a microservice

53
00:02:36,560 --> 00:02:38,965
or a piece of code
running on some machine.

54
00:02:38,965 --> 00:02:41,690
Messages are flying through
the system in a way that makes

55
00:02:41,690 --> 00:02:44,795
it really hard to debug
when something goes wrong.

56
00:02:44,795 --> 00:02:48,215
Coyote tests one
async path at a time,

57
00:02:48,215 --> 00:02:51,050
exploring all possible
paths through the system,

58
00:02:51,050 --> 00:02:52,985
and it does this very quickly.

59
00:02:52,985 --> 00:02:56,240
It also records this path so
that when it finds a bug,

60
00:02:56,240 --> 00:02:59,740
that bug is a 100
percent reproducible.

61
00:03:02,000 --> 00:03:04,365
That's still pretty abstract,

62
00:03:04,365 --> 00:03:08,640
so let me show you something
that is a real system.

63
00:03:09,410 --> 00:03:13,160
This is an implementation
of a complex fault

64
00:03:13,160 --> 00:03:16,355
tolerant cluster
protocol called Raft.

65
00:03:16,355 --> 00:03:19,880
Here you see five servers in
green all communicating with each

66
00:03:19,880 --> 00:03:23,975
other as they implement the
protocol to elect a cluster leader.

67
00:03:23,975 --> 00:03:27,785
Each server runs in parallel
with respect to the others,

68
00:03:27,785 --> 00:03:32,615
so that the messages are flying
around as you can see here.

69
00:03:32,615 --> 00:03:37,410
As you can imagine, this sort of
thing is really hard to debug.

70
00:03:38,060 --> 00:03:41,000
Coyote can help break
this down into something

71
00:03:41,000 --> 00:03:44,140
that's testable and debuggable.

72
00:03:44,140 --> 00:03:47,270
First, to use the Coyote
framework to declare

73
00:03:47,270 --> 00:03:50,630
your message types and
your state machines,

74
00:03:50,630 --> 00:03:52,415
which are the groups here,

75
00:03:52,415 --> 00:03:55,490
and the states inside each machine.

76
00:03:55,490 --> 00:03:57,755
So we see four states here.

77
00:03:57,755 --> 00:03:59,630
You also declare what are

78
00:03:59,630 --> 00:04:02,270
the valid events that can
be received in each state,

79
00:04:02,270 --> 00:04:04,220
then you write a Coyote test and run

80
00:04:04,220 --> 00:04:06,670
it using the Coyote test tool.

81
00:04:06,670 --> 00:04:09,530
In test mode, Coyote
takes over control

82
00:04:09,530 --> 00:04:11,930
of all concurrency and
non-determinism in

83
00:04:11,930 --> 00:04:15,560
your code and all possible timings

84
00:04:15,560 --> 00:04:19,460
of events in this
asynchronous system.

85
00:04:19,460 --> 00:04:22,280
Let me show you what
that looks like again.

86
00:04:22,280 --> 00:04:26,790
If I play that, you can see it
playing one message at a time.

87
00:04:29,570 --> 00:04:32,690
So Coyote is able to test your system

88
00:04:32,690 --> 00:04:35,990
one message at a time and
visualize the results.

89
00:04:35,990 --> 00:04:38,600
This is one test iteration containing

90
00:04:38,600 --> 00:04:42,880
one specific ordering of thousands
of messages through the system.

91
00:04:42,880 --> 00:04:48,140
In this case, Coyote
found a bug where two of

92
00:04:48,140 --> 00:04:50,390
the servers in this cluster

93
00:04:50,390 --> 00:04:53,240
become the cluster
leader at the same time,

94
00:04:53,240 --> 00:04:55,280
and that's these red nodes here,

95
00:04:55,280 --> 00:04:59,380
which is actually a problem
that violates the protocol.

96
00:04:59,380 --> 00:05:02,490
The really cool thing is that
when Coyote found this bug,

97
00:05:02,490 --> 00:05:04,190
it also recorded the exact message

98
00:05:04,190 --> 00:05:07,745
ordering that was required
to create that bug.

99
00:05:07,745 --> 00:05:11,660
So you can replay the bug instantly
in your debugger and you can

100
00:05:11,660 --> 00:05:12,860
actually debug it without

101
00:05:12,860 --> 00:05:15,980
a million different threads
going on at the same time.

102
00:05:15,980 --> 00:05:20,210
So when you use Coyote to build
these kinds of distributed applications,

103
00:05:20,210 --> 00:05:22,820
you get for free a powerful
testing tool that can

104
00:05:22,820 --> 00:05:27,930
intelligently test your code
and find bugs automatically.

105
00:05:28,310 --> 00:05:31,520
Even better, when Coyote
found a bug like this,

106
00:05:31,520 --> 00:05:34,160
it's also a 100 percent reproducible.

107
00:05:34,160 --> 00:05:38,600
The animation you just saw
is also greatly slowed down,

108
00:05:38,600 --> 00:05:41,345
just so that we can see
what's going on here.

109
00:05:41,345 --> 00:05:43,610
The Coyote tester itself can

110
00:05:43,610 --> 00:05:46,340
run hundreds of these
iterations per second,

111
00:05:46,340 --> 00:05:48,890
making it possible to search
the enormous space of

112
00:05:48,890 --> 00:05:52,745
possibilities to find even
the most difficult bugs.

113
00:05:52,745 --> 00:05:55,250
So this is like a search problem,

114
00:05:55,250 --> 00:05:57,680
and Microsoft Research has provided

115
00:05:57,680 --> 00:05:59,300
some built-in search algorithms to

116
00:05:59,300 --> 00:06:01,805
help narrow down the search for bugs.

117
00:06:01,805 --> 00:06:04,040
These have been tested
and verified with

118
00:06:04,040 --> 00:06:07,480
real customers working
on large code bases.

119
00:06:07,480 --> 00:06:10,110
So who's using Coyote?

120
00:06:10,110 --> 00:06:12,180
Several teams in Azure are using

121
00:06:12,180 --> 00:06:14,750
Coyote to build their
production services already,

122
00:06:14,750 --> 00:06:17,885
including various
teams in Azure Batch,

123
00:06:17,885 --> 00:06:21,485
Azure Blockchain, and Azure Compute.

124
00:06:21,485 --> 00:06:24,915
For example, a team in Azure
Batch is using Coyote to

125
00:06:24,915 --> 00:06:28,520
be able to check the correctness
of their failover logic.

126
00:06:28,520 --> 00:06:30,590
The Azure Batch team has over a

127
00:06:30,590 --> 00:06:33,905
100,000 lines of code
using Coyote framework.

128
00:06:33,905 --> 00:06:37,190
Another team in Azure
Compute used Coyote to help

129
00:06:37,190 --> 00:06:40,190
them move to a much more responsive
and asynchronous design,

130
00:06:40,190 --> 00:06:42,680
which enabled the Coyote lock

131
00:06:42,680 --> 00:06:45,845
free event-based actor
programming model.

132
00:06:45,845 --> 00:06:48,920
They actually got not only

133
00:06:48,920 --> 00:06:51,470
a better system using

134
00:06:51,470 --> 00:06:53,870
Coyote and a system that
could debug more easily,

135
00:06:53,870 --> 00:06:56,750
but their final system actually
performed better as well,

136
00:06:56,750 --> 00:06:58,760
which is really interesting.

137
00:06:58,760 --> 00:07:01,040
All these customers are reporting

138
00:07:01,040 --> 00:07:03,830
significant improvement
to productivity and

139
00:07:03,830 --> 00:07:05,930
confidence that their
systems are ready for

140
00:07:05,930 --> 00:07:09,390
production each time
they make a change.

141
00:07:09,950 --> 00:07:14,820
So Coyote provides two
programming models.

142
00:07:14,820 --> 00:07:19,670
One is based on the
task programming model,

143
00:07:19,670 --> 00:07:24,170
which is built on the .NET
Framework task platform.

144
00:07:24,170 --> 00:07:26,645
The second programming model is

145
00:07:26,645 --> 00:07:29,045
a more advanced actor
programming model,

146
00:07:29,045 --> 00:07:31,130
using events and state machines.

147
00:07:31,130 --> 00:07:32,690
I will show you both of

148
00:07:32,690 --> 00:07:35,909
these programming models
with some examples.

149
00:07:37,660 --> 00:07:40,265
First, the task model.

150
00:07:40,265 --> 00:07:44,495
This programming model offers
a task type that serves as a

151
00:07:44,495 --> 00:07:49,860
drop-in replacement for the native
.NET system threading task.

152
00:07:50,780 --> 00:07:55,685
Tasks represent an
asynchronous operation and

153
00:07:55,685 --> 00:08:01,060
integrates really nicely with the
C# feature, async, and await.

154
00:08:01,060 --> 00:08:03,775
In production, a Coyote task

155
00:08:03,775 --> 00:08:07,475
executes with the same
semantics as the .NET task.

156
00:08:07,475 --> 00:08:11,345
In fact, it's a very thin
wrapper around the native task,

157
00:08:11,345 --> 00:08:15,350
which means it has a very
minimal overhead in production.

158
00:08:15,350 --> 00:08:18,410
During testing, however, is where

159
00:08:18,410 --> 00:08:21,125
the magic happens and
Coyote can take over

160
00:08:21,125 --> 00:08:26,840
the execution of all tasks
during the test and can explore

161
00:08:26,840 --> 00:08:29,555
various different
interleavings between

162
00:08:29,555 --> 00:08:33,990
the scheduling of all those
tasks to help find bugs.

163
00:08:34,450 --> 00:08:38,500
This model is in preview and
is available right now.

164
00:08:38,500 --> 00:08:40,445
So let's take a look at some code

165
00:08:40,445 --> 00:08:42,650
that uses the task programming model.

166
00:08:42,650 --> 00:08:45,560
As is always the tradition
with this sort of thing

167
00:08:45,560 --> 00:08:51,630
is to show the simplest possible
HelloWorldTasks example.

168
00:08:51,630 --> 00:08:54,095
This code is available in GitHub,

169
00:08:54,095 --> 00:08:55,955
so I'm going to go over there.

170
00:08:55,955 --> 00:08:58,145
I have the repo right here

171
00:08:58,145 --> 00:09:08,310
and I'm going to load
"HelloWorldTasks" into Visual Studio.

172
00:09:08,310 --> 00:09:12,259
Here we see a simple
console application

173
00:09:12,259 --> 00:09:15,585
with a program and
a main entry point,

174
00:09:15,585 --> 00:09:19,560
and we see that we have
a class called Greeter.

175
00:09:20,290 --> 00:09:23,690
The Greeter looks like
a normal C# class with

176
00:09:23,690 --> 00:09:27,400
an async method called
WriteWithDelayAsync.

177
00:09:27,400 --> 00:09:34,120
It simply sets a member field
after some delay. There's the setter.

178
00:09:34,120 --> 00:09:37,385
The run async method starts

179
00:09:37,385 --> 00:09:42,515
five separate tasks on purpose
to make them run in parallel,

180
00:09:42,515 --> 00:09:45,570
calling that async method.

181
00:09:45,790 --> 00:09:50,000
Then it uses this
construct here on Task

182
00:09:50,000 --> 00:09:53,960
to wait for all five of
those tasks to complete.

183
00:09:53,960 --> 00:09:58,500
Then it writes out the
final value that was set.

184
00:09:58,500 --> 00:10:01,430
Clearly, this is setting
up a race condition where

185
00:10:01,430 --> 00:10:04,430
the value will be
randomly set to one of

186
00:10:04,430 --> 00:10:08,630
these two different strings
depending on which task

187
00:10:08,630 --> 00:10:13,950
gets scheduled last in
this parallel operation.

188
00:10:14,740 --> 00:10:16,955
So to finish this sample,

189
00:10:16,955 --> 00:10:18,550
we write an Assert here.

190
00:10:18,550 --> 00:10:22,070
In this case, we wrongly
assert that the final value

191
00:10:22,070 --> 00:10:26,340
after running these five tasks
will always be HelloWorld.

192
00:10:26,340 --> 00:10:28,430
Clearly, that's not
always going to be

193
00:10:28,430 --> 00:10:32,090
true because we have one
that sets it to GoodMorning.

194
00:10:32,090 --> 00:10:35,240
So we've injected a bug
into this code on purpose,

195
00:10:35,240 --> 00:10:38,460
and let's run it and
see what happens.

196
00:10:40,530 --> 00:10:45,100
I went ahead and built that
and let me run this version

197
00:10:45,100 --> 00:10:49,600
here in the window.

198
00:10:49,600 --> 00:10:51,940
Right off the bat, it hit the bug,

199
00:10:51,940 --> 00:10:54,820
but let's run it again
and again and again.

200
00:10:54,820 --> 00:10:56,050
You can see it randomly

201
00:10:56,050 --> 00:11:01,580
succeeds or fails depending
on that thread scheduling.

202
00:11:01,590 --> 00:11:08,215
So this is basically the definition
of a non-deterministic bug.

203
00:11:08,215 --> 00:11:10,660
You'll see that the
Coyote website talks

204
00:11:10,660 --> 00:11:12,760
a lot about non-determinism

205
00:11:12,760 --> 00:11:15,385
because that's one of the
things that Coyote can be

206
00:11:15,385 --> 00:11:18,685
really good at helping you test.

207
00:11:18,685 --> 00:11:21,280
So what I'm going to do
is show you how to run

208
00:11:21,280 --> 00:11:24,535
this program in the Coyote test tool.

209
00:11:24,535 --> 00:11:25,780
But before I do that, let me just

210
00:11:25,780 --> 00:11:27,730
show you how that's going to work.

211
00:11:27,730 --> 00:11:29,935
Back in the main program,

212
00:11:29,935 --> 00:11:32,740
you'll see that there's
a Coyote test attribute

213
00:11:32,740 --> 00:11:35,140
on this Execute method.

214
00:11:35,140 --> 00:11:36,940
This test to attribute allows

215
00:11:36,940 --> 00:11:42,625
the Coyote test tool to test this
program in a special test mode.

216
00:11:42,625 --> 00:11:47,410
The Coyote test tool
lives in the Coyote repo.

217
00:11:47,410 --> 00:11:51,440
If you build the Coyote source code,

218
00:11:52,770 --> 00:11:57,265
this is building the Coyote
project from source.

219
00:11:57,265 --> 00:11:59,650
What we'll see is
it's building all of

220
00:11:59,650 --> 00:12:02,395
the Coyote runtime projects here,

221
00:12:02,395 --> 00:12:05,170
including the Coyote test
tool that we're going to

222
00:12:05,170 --> 00:12:08,359
use to test our HelloWorld
application.

223
00:12:08,640 --> 00:12:12,145
There's the Coyote test tool
being built right there.

224
00:12:12,145 --> 00:12:14,600
That's the one we'll use.

225
00:12:16,530 --> 00:12:20,960
Great. Now, we go back
to the samples folder.

226
00:12:22,860 --> 00:12:26,050
We're going to use
that Coyote test tool.

227
00:12:26,050 --> 00:12:27,700
If you just hit enter here,

228
00:12:27,700 --> 00:12:30,190
it shows you all the
command line arguments

229
00:12:30,190 --> 00:12:32,710
that you can pass to this tool,

230
00:12:32,710 --> 00:12:36,220
including what you're testing,

231
00:12:36,220 --> 00:12:38,740
which is passed as an assembly path.

232
00:12:38,740 --> 00:12:44,305
So we're going to test what we
just built in the Bin folder.

233
00:12:44,305 --> 00:12:53,545
We have to pick the same .NET
platform, .NET46, HelloWorldTasks,

234
00:12:53,545 --> 00:12:57,070
and we'll do 100 test iterations

235
00:12:57,070 --> 00:12:59,770
and we'll see if it can find a bug.

236
00:12:59,770 --> 00:13:02,410
So as we expected,

237
00:13:02,410 --> 00:13:05,245
because the bug was
hardcoded into this program,

238
00:13:05,245 --> 00:13:07,900
when we run this in
the Coyote test tool,

239
00:13:07,900 --> 00:13:11,365
we need a bunch of iterations,

240
00:13:11,365 --> 00:13:14,540
which is what I passed in
that command line there.

241
00:13:14,610 --> 00:13:19,120
Then it hits the bug, so it did
seven iterations in this case,

242
00:13:19,120 --> 00:13:22,945
and then it found a bug which
is reported - found one bug.

243
00:13:22,945 --> 00:13:26,080
It provides a log file that

244
00:13:26,080 --> 00:13:28,870
tells you exactly what happened
when that test failed.

245
00:13:28,870 --> 00:13:34,330
So let's look at that, right here.

246
00:13:34,330 --> 00:13:36,190
You can see the log file says

247
00:13:36,190 --> 00:13:38,590
the value was 'Good Morning'
instead of "Hello,"

248
00:13:38,590 --> 00:13:40,765
that's because of the failed assert.

249
00:13:40,765 --> 00:13:43,810
It also gives you the
stack trace of where

250
00:13:43,810 --> 00:13:47,780
that bug was found in your
program, which can be handy.

251
00:13:48,840 --> 00:13:52,975
Now, the interesting thing
is that it also provides

252
00:13:52,975 --> 00:13:57,010
a schedule on how it
created that bug,

253
00:13:57,010 --> 00:14:00,770
and this is where the real
magic happens with Coyote.

254
00:14:00,990 --> 00:14:03,460
What you can do is you can actually,

255
00:14:03,460 --> 00:14:06,775
instead of test, is a search for bugs,

256
00:14:06,775 --> 00:14:09,745
but you can replay that schedule.

257
00:14:09,745 --> 00:14:13,750
Replay will jump straight to the bug.

258
00:14:13,750 --> 00:14:16,450
So you say replay,

259
00:14:16,450 --> 00:14:19,460
I have to give it the schedule,

260
00:14:20,400 --> 00:14:22,780
and instantly it found the bug.

261
00:14:22,780 --> 00:14:24,010
It didn't have to search this time,

262
00:14:24,010 --> 00:14:25,840
it's actually got the bug already.

263
00:14:25,840 --> 00:14:28,750
I can even run that
with a break command,

264
00:14:28,750 --> 00:14:31,780
which will put us on a
breakpoint inside Visual Studio,

265
00:14:31,780 --> 00:14:33,820
and we can start debugging

266
00:14:33,820 --> 00:14:37,610
this thing with 100 percent
certainty that that bug will happen.

267
00:14:39,210 --> 00:14:41,680
So this is really huge,

268
00:14:41,680 --> 00:14:44,860
for those of you who've
spent way too much time

269
00:14:44,860 --> 00:14:48,865
debugging these sorts of
problems with multithreading,

270
00:14:48,865 --> 00:14:50,770
it can be extremely time-consuming.

271
00:14:50,770 --> 00:14:55,720
I've spent days trying to find a
really nasty multithreading bug,

272
00:14:55,720 --> 00:14:59,725
and Coyote actually makes these
things debuggable quickly,

273
00:14:59,725 --> 00:15:05,180
100 percent reproducible, super
useful feature of Coyote.

274
00:15:08,060 --> 00:15:10,980
There are some challenges with tasks,

275
00:15:10,980 --> 00:15:13,600
which I'll walk through here.

276
00:15:18,540 --> 00:15:20,770
Let me go back to Visual Studio.

277
00:15:20,770 --> 00:15:22,570
When you write a bigger program,

278
00:15:22,570 --> 00:15:24,310
like the coffee machine example

279
00:15:24,310 --> 00:15:26,680
that we'll look at in a little bit.

280
00:15:26,680 --> 00:15:29,140
Oftentimes you'll find yourself,

281
00:15:29,140 --> 00:15:31,390
especially if you have a lot
of multithreading going on,

282
00:15:31,390 --> 00:15:32,830
you'll find yourself having to use

283
00:15:32,830 --> 00:15:36,069
the lock statement
with some sort of sync object,

284
00:15:36,069 --> 00:15:39,430
and you now have to protect

285
00:15:39,430 --> 00:15:44,200
the update of local state
from multithreading issues.

286
00:15:44,200 --> 00:15:46,960
Well, the lock statement
is interesting.

287
00:15:46,960 --> 00:15:49,255
If I call out to some other method,

288
00:15:49,255 --> 00:15:53,710
I now have to worry about deadlocks.

289
00:15:53,710 --> 00:15:55,870
If I call a method
and that method

290
00:15:55,870 --> 00:15:57,970
starts another AsyncTask
there and waits for it.

291
00:15:57,970 --> 00:16:00,100
That AsyncTask then calls back into

292
00:16:00,100 --> 00:16:03,400
this object and that tries
to lock, I have a deadlock.

293
00:16:03,400 --> 00:16:06,860
Deadlocks are also
difficult to debug.

294
00:16:07,290 --> 00:16:10,120
The other thing is that when you have

295
00:16:10,120 --> 00:16:12,070
all this Async code
and you need locks,

296
00:16:12,070 --> 00:16:15,520
you can't use the
await keyword inside.

297
00:16:15,520 --> 00:16:17,170
In fact the IntelliSense is

298
00:16:17,170 --> 00:16:19,135
not even letting me
because it's not allowed.

299
00:16:19,135 --> 00:16:21,430
You're not allowed
to use await inside

300
00:16:21,430 --> 00:16:26,080
a lock because that can be
also a guarantee for deadlocks.

301
00:16:26,080 --> 00:16:31,240
So there are some non-trivial
aspects to writing thread

302
00:16:31,240 --> 00:16:33,820
safe code that you run into if you

303
00:16:33,820 --> 00:16:37,430
have a lot of parallel
tasks in your programs.

304
00:16:37,500 --> 00:16:41,590
Deadlocks can't use Async,

305
00:16:41,590 --> 00:16:43,960
and you have to protect your state.

306
00:16:43,960 --> 00:16:47,665
So async methods are a
powerful feature of C#.

307
00:16:47,665 --> 00:16:49,705
Async await is a really cool thing,

308
00:16:49,705 --> 00:16:53,890
but you have to be careful,
there are complications.

309
00:16:53,890 --> 00:16:55,600
So this leads us to

310
00:16:55,600 --> 00:16:58,090
the other programming model
that Coyote provides,

311
00:16:58,090 --> 00:17:00,775
which is an Actor-based
programming model.

312
00:17:00,775 --> 00:17:03,910
There's actually a lot of
computer science research into

313
00:17:03,910 --> 00:17:05,680
Actor programming models that show

314
00:17:05,680 --> 00:17:08,170
some great advantages
of using this model.

315
00:17:08,170 --> 00:17:09,430
The first thing that we do with

316
00:17:09,430 --> 00:17:13,000
Actors is you cannot
call them directly,

317
00:17:13,000 --> 00:17:17,170
you have to send events to them
and that goes through an inbox.

318
00:17:17,170 --> 00:17:20,530
So each Actor has an
inbox, it's kind of like e-mail.

319
00:17:20,530 --> 00:17:22,240
You send a message to

320
00:17:22,240 --> 00:17:25,900
an Actor and you cannot call
methods directly on the Actor.

321
00:17:25,900 --> 00:17:27,655
The only thing you have is an ID,

322
00:17:27,655 --> 00:17:30,760
which is the thing
that you need to send

323
00:17:30,760 --> 00:17:34,255
the message to an Actor,
that's the ActorId.

324
00:17:34,255 --> 00:17:39,355
Think of an Event as

325
00:17:39,355 --> 00:17:42,895
a bundle of method parameters

326
00:17:42,895 --> 00:17:46,060
that are wrapped up in an
object called an Event,

327
00:17:46,060 --> 00:17:48,325
and that's what you
send to the Actor.

328
00:17:48,325 --> 00:17:50,440
But that Event then is

329
00:17:50,440 --> 00:17:52,270
something that can live
outside of any call stack,

330
00:17:52,270 --> 00:17:55,720
unlike method parameters that
are always on a call stack.

331
00:17:55,720 --> 00:17:59,005
An Event can just live
forever in an inbox,

332
00:17:59,005 --> 00:18:01,345
independent of call stacks.

333
00:18:01,345 --> 00:18:03,820
There's a lot of
information on Wikipedia

334
00:18:03,820 --> 00:18:05,920
about this programming model
and how it came about.

335
00:18:05,920 --> 00:18:09,950
It's very popular in the
world of distributed systems.

336
00:18:11,040 --> 00:18:13,600
So Events can also easily be

337
00:18:13,600 --> 00:18:16,180
serialized to create
a distributed system.

338
00:18:16,180 --> 00:18:17,890
So now your Events are actually going

339
00:18:17,890 --> 00:18:20,635
across the wire to other systems.

340
00:18:20,635 --> 00:18:25,690
So what we do with
Actors in Coyote is,

341
00:18:25,690 --> 00:18:30,640
we run each Actor in a
separate thread or task,

342
00:18:30,640 --> 00:18:36,940
but the Actor only dequeues and
processes one Event at a time,

343
00:18:36,940 --> 00:18:39,520
which means the Actor
internal implementation

344
00:18:39,520 --> 00:18:41,455
doesn't need to worry
about multi-threading.

345
00:18:41,455 --> 00:18:43,465
So we don't need to do any locks.

346
00:18:43,465 --> 00:18:45,730
Which is why we said that

347
00:18:45,730 --> 00:18:47,740
Azure Batch got a
performance improvement,

348
00:18:47,740 --> 00:18:50,815
because they were doing lock
free programming, basically,

349
00:18:50,815 --> 00:18:54,460
and the parallelism
happened at a higher level.

350
00:18:54,460 --> 00:18:58,225
Instead of doing parallelism
at the method level,

351
00:18:58,225 --> 00:19:00,190
you're doing it at the Actor level,

352
00:19:00,190 --> 00:19:03,280
that actually greatly simplifies
your programming model.

353
00:19:03,280 --> 00:19:05,500
It's a little bit
similar to ASP.NET that

354
00:19:05,500 --> 00:19:08,890
says you could process one
HTTP request at a time.

355
00:19:08,890 --> 00:19:13,810
Here an Actor processes
one Event at a time,

356
00:19:13,810 --> 00:19:16,285
so it's a lock-free
programming model.

357
00:19:16,285 --> 00:19:17,860
So let's take a look at

358
00:19:17,860 --> 00:19:23,430
the simplest possible Actor
program, HelloWorld.

359
00:19:23,430 --> 00:19:27,030
So again, that's here in

360
00:19:27,030 --> 00:19:31,815
GitHub and we'll load
that into Visual Studio.

361
00:19:31,815 --> 00:19:35,950
HelloWorldActors, right here.

362
00:19:37,470 --> 00:19:40,570
Has a very similar program with

363
00:19:40,570 --> 00:19:44,245
a main entry point
and a Greeter class,

364
00:19:44,245 --> 00:19:48,640
except this time, the
Greeter class is an Actor.

365
00:19:48,640 --> 00:19:52,615
You can see that this Actor

366
00:19:52,615 --> 00:19:57,625
is provided by the
Coyote Actor namespace.

367
00:19:57,625 --> 00:20:01,330
So with Actors, you declare what

368
00:20:01,330 --> 00:20:04,960
types of Events can be received
with a custom attribute.

369
00:20:04,960 --> 00:20:08,245
This says that the Greeter
is expecting to receive

370
00:20:08,245 --> 00:20:12,775
a request for Greetings
in this Event type.

371
00:20:12,775 --> 00:20:16,435
So what we can then do is go
to the definition of an Event.

372
00:20:16,435 --> 00:20:19,764
Event is also provided
by the Coyote namespace,

373
00:20:19,764 --> 00:20:23,155
and here you can put
data inside your Events.

374
00:20:23,155 --> 00:20:26,200
So here we've got one piece
of data that we're sending,

375
00:20:26,200 --> 00:20:28,750
which is the ID of the Caller.

376
00:20:28,750 --> 00:20:32,125
So the Caller is calling the Greeter,

377
00:20:32,125 --> 00:20:35,950
requesting that the
Greeter return a Greeting.

378
00:20:35,950 --> 00:20:39,160
The Greeter will return
this Event down here,

379
00:20:39,160 --> 00:20:43,915
which is another Event which contains
a Greeting just as a string.

380
00:20:43,915 --> 00:20:50,065
So this is how you bundle these
Events into various Event objects,

381
00:20:50,065 --> 00:20:53,140
and you can now send
them to the Actor.

382
00:20:53,140 --> 00:20:57,430
So you declare what type of
Event you can receive or handle.

383
00:20:57,430 --> 00:21:00,190
So this Actor can handle
RequestGreetingEvents,

384
00:21:00,190 --> 00:21:03,100
and this tells Coyote

385
00:21:03,100 --> 00:21:06,355
what method to call when
that Event is received.

386
00:21:06,355 --> 00:21:09,535
So it's going to call
HandleGreeting right here.

387
00:21:09,535 --> 00:21:13,670
We can cast that back to
the type we're expecting.

388
00:21:14,070 --> 00:21:17,380
We can create a Greeting using

389
00:21:17,380 --> 00:21:20,560
a random choice
between "Hello World!"

390
00:21:20,560 --> 00:21:22,150
and "Good Morning". So
this is actually going

391
00:21:22,150 --> 00:21:24,235
to choose randomly between those two.

392
00:21:24,235 --> 00:21:28,570
Random number generation is also
provided by the Actor base class,

393
00:21:28,570 --> 00:21:30,850
because Coyote wants to actually be

394
00:21:30,850 --> 00:21:35,390
involved in the generation of
random numbers at test time.

395
00:21:35,520 --> 00:21:39,400
The Greeter then simply does a Send

396
00:21:39,400 --> 00:21:43,075
Event to send the Greeting
back to the Caller,

397
00:21:43,075 --> 00:21:45,205
which is provided in this Event,

398
00:21:45,205 --> 00:21:48,925
and with a chance of one in 10.

399
00:21:48,925 --> 00:21:51,460
So that's what Random
Boolean(10) means.

400
00:21:51,460 --> 00:21:54,580
A one in 10 chance it's going
to send a second greeting,

401
00:21:54,580 --> 00:21:56,335
and this is our bug in this case,

402
00:21:56,335 --> 00:21:58,720
we're injecting a bug in
here on purpose that sends

403
00:21:58,720 --> 00:22:02,840
too many Greetings
back to the Caller.

404
00:22:04,320 --> 00:22:08,230
So how do you test an Actor?

405
00:22:08,230 --> 00:22:10,825
Over in the program,

406
00:22:10,825 --> 00:22:18,310
we have another class
called a TestActor.

407
00:22:18,310 --> 00:22:21,310
The TestActor is going
to act like a client,

408
00:22:21,310 --> 00:22:22,735
if you like, of the greeter.

409
00:22:22,735 --> 00:22:25,645
So the TestActor has to

410
00:22:25,645 --> 00:22:30,955
create the Greeter and calls
SendEvent requesting a Greeting.

411
00:22:30,955 --> 00:22:35,905
So this is how we test our
Greeter by creating the Actor.

412
00:22:35,905 --> 00:22:40,060
Again, what we get back here is
not an instance of a C# object.

413
00:22:40,060 --> 00:22:42,730
We don't ever have permission to see

414
00:22:42,730 --> 00:22:44,410
the real instance of

415
00:22:44,410 --> 00:22:47,185
this object that's created
by the Coyote runtime.

416
00:22:47,185 --> 00:22:52,510
This ensures proper decoupling
between your various Actors,

417
00:22:52,510 --> 00:22:54,580
and is able to then

418
00:22:54,580 --> 00:22:57,640
guarantee this thread safety
that we talked about,

419
00:22:57,640 --> 00:23:00,640
and that only one message
is handled at a time.

420
00:23:00,640 --> 00:23:03,685
So what I get back is an ActorID.

421
00:23:03,685 --> 00:23:07,700
That ActorID is then what
we use to send an Event.

422
00:23:08,670 --> 00:23:14,590
Here, we're going to send up to
five random number generation,

423
00:23:14,590 --> 00:23:16,120
one plus random to five.

424
00:23:16,120 --> 00:23:22,800
So we should send one to five
messages here to that Greeter,

425
00:23:22,800 --> 00:23:26,145
and we'll store in this
little variable here,

426
00:23:26,145 --> 00:23:29,310
Count how many greetings we sent.

427
00:23:29,310 --> 00:23:33,955
Now, notice that the
TestActor is also an Actor.

428
00:23:33,955 --> 00:23:35,770
So just like the Greeter,

429
00:23:35,770 --> 00:23:37,720
this TestActor tells Coyote with

430
00:23:37,720 --> 00:23:41,395
a custom attribute what kind
of Events it can receive,

431
00:23:41,395 --> 00:23:44,000
which is this GreetingEvent.

432
00:23:44,580 --> 00:23:46,960
When it receives a GreetingEvent,

433
00:23:46,960 --> 00:23:48,715
call the HandleGreeting method.

434
00:23:48,715 --> 00:23:50,935
The HandleGreeting
method is down here.

435
00:23:50,935 --> 00:23:53,680
We're able to cast that
back to GreetingEvent

436
00:23:53,680 --> 00:23:57,055
and we decrement the Count.

437
00:23:57,055 --> 00:24:01,465
So here we're actually going to
start writing some test code.

438
00:24:01,465 --> 00:24:03,880
We will decrement the Count

439
00:24:03,880 --> 00:24:06,190
and print out what

440
00:24:06,190 --> 00:24:08,200
the Greeting was, just so
we can see it in the log,

441
00:24:08,200 --> 00:24:13,000
and we're going to assert that
this Count never becomes negative.

442
00:24:13,000 --> 00:24:14,440
If it does, then we have

443
00:24:14,440 --> 00:24:17,780
a problem that there are too
many Greetings returned.

444
00:24:18,660 --> 00:24:21,460
Of course, we've injected
a bug in here on

445
00:24:21,460 --> 00:24:23,365
purpose that will return
too many Greetings,

446
00:24:23,365 --> 00:24:25,435
and so with a one in 10 chance,

447
00:24:25,435 --> 00:24:28,060
this program should
report that error.

448
00:24:28,060 --> 00:24:30,710
So we go ahead and build that,

449
00:24:31,680 --> 00:24:34,795
and we'll run that version,

450
00:24:34,795 --> 00:24:39,650
and I'll just bring it over
to our Console Window,

451
00:24:40,530 --> 00:24:43,495
run it like this.

452
00:24:43,495 --> 00:24:48,010
When you run a Coyote program like
this outside the Coyote tester,

453
00:24:48,010 --> 00:24:49,735
we call that running in production.

454
00:24:49,735 --> 00:24:51,250
This is exactly what you would

455
00:24:51,250 --> 00:24:53,200
do with a production Coyote program,

456
00:24:53,200 --> 00:24:56,095
you just run it like
any other C# program.

457
00:24:56,095 --> 00:25:01,330
Coyote is just a library that
is loaded in the process.

458
00:25:01,330 --> 00:25:03,955
So we've run it once,
we've run it twice,

459
00:25:03,955 --> 00:25:05,620
this time we've got five Greetings.

460
00:25:05,620 --> 00:25:08,560
So far, we haven't seen that
bug because there's only a

461
00:25:08,560 --> 00:25:12,205
one in 10 chance we'll ever
actually get that bug infect.

462
00:25:12,205 --> 00:25:15,370
There we go, finally. So I had to
run it a lot of times manually.

463
00:25:15,370 --> 00:25:17,860
So this is the thing
with non-determinism,

464
00:25:17,860 --> 00:25:20,740
you'll typically find yourself
having to run a lot of

465
00:25:20,740 --> 00:25:22,390
iterations before you actually

466
00:25:22,390 --> 00:25:24,745
trigger the bug that
you're looking for.

467
00:25:24,745 --> 00:25:26,845
Then when you get the bug,
how do you reproduce it?

468
00:25:26,845 --> 00:25:29,035
It's so hard to reproduce
in the first place.

469
00:25:29,035 --> 00:25:31,225
So let's run this in Coyote,

470
00:25:31,225 --> 00:25:34,130
just like I did with the other one,

471
00:25:35,190 --> 00:25:42,730
we'll run Coyote test.

472
00:25:42,730 --> 00:25:44,380
We have to have the
same .NET platform.

473
00:25:44,380 --> 00:25:46,450
So we'll run the 46 version.

474
00:25:46,450 --> 00:25:48,130
We just ran one iteration,

475
00:25:48,130 --> 00:25:50,690
but let's run 100 iterations.

476
00:25:53,460 --> 00:25:56,980
Whoop! Found the bug
right away in that case.

477
00:25:56,980 --> 00:25:58,900
But let's do it again and again.

478
00:25:58,900 --> 00:26:00,340
You can see it's
finding the bug really

479
00:26:00,340 --> 00:26:03,020
quickly every time I run this.

480
00:26:03,030 --> 00:26:06,220
Again, as before, there's a log file.

481
00:26:06,220 --> 00:26:08,050
This time the log file is a
little bit more interesting,

482
00:26:08,050 --> 00:26:09,580
because it's showing you more of

483
00:26:09,580 --> 00:26:11,950
the Coyote Actor runtime activity,

484
00:26:11,950 --> 00:26:15,355
including messages
when they are sent.

485
00:26:15,355 --> 00:26:18,250
So we can see a whole
bunch of send operations,

486
00:26:18,250 --> 00:26:20,769
and then as the messages get dequeued

487
00:26:20,769 --> 00:26:24,880
and executed by an
action on the Greeter.

488
00:26:24,880 --> 00:26:27,325
So this is the Handle
Greeting action.

489
00:26:27,325 --> 00:26:29,785
Then finally, we see the assert.

490
00:26:29,785 --> 00:26:31,675
Too many greetings returned,

491
00:26:31,675 --> 00:26:34,730
which was triggered by that assert.

492
00:26:35,040 --> 00:26:39,115
Again, we can replay this
as well, just as before,

493
00:26:39,115 --> 00:26:44,185
and we can get the 100
percent reproducible bug.

494
00:26:44,185 --> 00:26:47,560
Now, let's take a look
at a bigger example.

495
00:26:47,560 --> 00:26:49,885
We have the coffee machine example,

496
00:26:49,885 --> 00:26:53,020
where we also have an
asynchronous version of

497
00:26:53,020 --> 00:26:58,735
the coffee machine up here on GitHub
using async tasks right here.

498
00:26:58,735 --> 00:27:01,270
You can look into that
in your own time.

499
00:27:01,270 --> 00:27:03,250
But if you check out the code,

500
00:27:03,250 --> 00:27:05,515
you'll see that the
task-based version

501
00:27:05,515 --> 00:27:08,155
of the coffee machine
is using a lot of locks

502
00:27:08,155 --> 00:27:14,250
and even needs async locks in
order to get its state correct.

503
00:27:14,250 --> 00:27:16,815
The Actor version is

504
00:27:16,815 --> 00:27:18,510
lock-free and that's the one I want

505
00:27:18,510 --> 00:27:20,520
to look at in a little
bit more detail here.

506
00:27:20,520 --> 00:27:23,960
So what is this coffee
machine example about?

507
00:27:23,960 --> 00:27:27,310
The coffee machine example shows
you how to build a state machine.

508
00:27:27,310 --> 00:27:30,670
So Coyote Actors not only
provide an Actor model,

509
00:27:30,670 --> 00:27:34,150
but they provide a first-class
state machine model.

510
00:27:34,150 --> 00:27:37,075
So this is a fun, little coffee
machine that I have in my kitchen,

511
00:27:37,075 --> 00:27:38,925
and that reminds me,

512
00:27:38,925 --> 00:27:43,570
I need some coffee, very good.

513
00:27:44,190 --> 00:27:48,250
It has a state machine.
So what does it do?

514
00:27:48,250 --> 00:27:50,815
That coffee machine, first
of all when you boot it up,

515
00:27:50,815 --> 00:27:52,900
it checks the state of everything.

516
00:27:52,900 --> 00:27:55,760
What's the water level?
What's the coffee level?

517
00:27:56,400 --> 00:27:58,630
It has a water heater, of course,

518
00:27:58,630 --> 00:27:59,995
it's got to heat up its water.

519
00:27:59,995 --> 00:28:01,555
So it can make steam,

520
00:28:01,555 --> 00:28:03,175
and it's monitoring that.

521
00:28:03,175 --> 00:28:04,630
When it's ready, you can press

522
00:28:04,630 --> 00:28:06,640
the make coffee button and it'll

523
00:28:06,640 --> 00:28:08,740
run the grinder which
will grind the beans.

524
00:28:08,740 --> 00:28:10,870
It will then fill up
that little filter thing

525
00:28:10,870 --> 00:28:12,955
that pumps the water through,

526
00:28:12,955 --> 00:28:15,595
starts making shots. The
shots come out at the bottom,

527
00:28:15,595 --> 00:28:19,660
and of course some things can go
wrong, as in always with machines,

528
00:28:19,660 --> 00:28:23,575
so you can run out of water
and a refill is required.

529
00:28:23,575 --> 00:28:25,120
This machine, obviously you need

530
00:28:25,120 --> 00:28:26,680
a manual refilling process

531
00:28:26,680 --> 00:28:29,210
for both the coffee
beans and for water.

532
00:28:29,210 --> 00:28:31,620
Otherwise, if everything's good,

533
00:28:31,620 --> 00:28:34,170
it can clean itself up and
go back to the ready-state.

534
00:28:34,170 --> 00:28:35,760
This is all implemented in

535
00:28:35,760 --> 00:28:39,780
the coffee machine example using
Coyote Actor programming model.

536
00:28:39,780 --> 00:28:49,510
Let's take a look at that in
Visual Studio, CoffeeMachineActors.

537
00:28:54,960 --> 00:29:01,825
All right. So the CoffeeMachineActors
has a CoffeeMachine,

538
00:29:01,825 --> 00:29:05,635
and this is a new concept

539
00:29:05,635 --> 00:29:07,405
in Coyote that I haven't
talked about yet,

540
00:29:07,405 --> 00:29:09,085
which is StateMachines.

541
00:29:09,085 --> 00:29:13,315
A StateMachine in Coyote is
a special type of Actor that

542
00:29:13,315 --> 00:29:15,460
understands all of those states

543
00:29:15,460 --> 00:29:18,490
that you saw in that state diagram.

544
00:29:18,490 --> 00:29:21,445
Now in a StateMachine,

545
00:29:21,445 --> 00:29:24,640
what you do is you declare,

546
00:29:24,640 --> 00:29:26,350
so it's also declarative,

547
00:29:26,350 --> 00:29:30,730
you declare the States
of the machine with

548
00:29:30,730 --> 00:29:35,515
a class that inherits from
the Coyote State base class.

549
00:29:35,515 --> 00:29:38,410
State is a nested class
inside StateMachine.

550
00:29:38,410 --> 00:29:40,210
So this is telling Coyote that

551
00:29:40,210 --> 00:29:43,975
this class has a State
called CheckSensors.

552
00:29:43,975 --> 00:29:47,665
Now remember with regular Actors,

553
00:29:47,665 --> 00:29:49,375
these were all at the class level.

554
00:29:49,375 --> 00:29:50,860
But now with StateMachines,

555
00:29:50,860 --> 00:29:53,830
we can move that down
into the State-level,

556
00:29:53,830 --> 00:29:55,180
so for each State,

557
00:29:55,180 --> 00:29:57,430
you can declare what
Events are valid,

558
00:29:57,430 --> 00:29:59,920
what can you do when
you're in that State.

559
00:29:59,920 --> 00:30:03,085
You can also tell Coyote
to defer certain States.

560
00:30:03,085 --> 00:30:06,040
So don't try to make a coffee
yet because we're not ready.

561
00:30:06,040 --> 00:30:08,200
You can also have a
special Event that

562
00:30:08,200 --> 00:30:10,735
happens when we enter this State.

563
00:30:10,735 --> 00:30:13,690
So this is like a
set-up piece of code

564
00:30:13,690 --> 00:30:16,750
that happens when we enter
the CheckSensor State.

565
00:30:16,750 --> 00:30:20,230
What do we do? Well, what
can we do with Actors?

566
00:30:20,230 --> 00:30:22,345
We can send Events. So what do we do?

567
00:30:22,345 --> 00:30:24,460
We send Events to the CoffeeGrinder,

568
00:30:24,460 --> 00:30:26,740
and we tell it to turn
off the CoffeeGrinder,

569
00:30:26,740 --> 00:30:27,970
we turn off the WaterPump,

570
00:30:27,970 --> 00:30:29,830
we turn off the WaterHeater.

571
00:30:29,830 --> 00:30:33,670
We also send some read Events over to

572
00:30:33,670 --> 00:30:35,530
those various sensors to

573
00:30:35,530 --> 00:30:37,270
read the water level,
read the hopper level,

574
00:30:37,270 --> 00:30:39,730
because we want to make sure the
beginning of this StateMachine

575
00:30:39,730 --> 00:30:43,030
that all the sensors
are in a good State,

576
00:30:43,030 --> 00:30:46,900
that we actually have water, that
we can make coffee and so on.

577
00:30:46,900 --> 00:30:50,065
So since we sent these read requests,

578
00:30:50,065 --> 00:30:53,950
that's why we're getting back
four read responses basically,

579
00:30:53,950 --> 00:30:56,125
these are the four Events
that were expecting back.

580
00:30:56,125 --> 00:30:57,730
These can all happen completely

581
00:30:57,730 --> 00:31:00,775
asynchronously depending
on thread scheduling.

582
00:31:00,775 --> 00:31:05,530
But our code is
handling those Events.

583
00:31:05,530 --> 00:31:10,675
So here's an example of when
we get back the water level,

584
00:31:10,675 --> 00:31:12,115
we handle that right here.

585
00:31:12,115 --> 00:31:14,950
We get a water-level, we store
it in a local member variable,

586
00:31:14,950 --> 00:31:18,730
we print it out and we check to
see if the water level is empty.

587
00:31:18,730 --> 00:31:21,730
If it's empty, then we have
to go to a different State,

588
00:31:21,730 --> 00:31:24,910
and here you can see a more
state machinery showing

589
00:31:24,910 --> 00:31:26,830
up where we tell Coyote that

590
00:31:26,830 --> 00:31:29,410
we're going to transition
to a different State.

591
00:31:29,410 --> 00:31:31,450
This can be done either in

592
00:31:31,450 --> 00:31:34,870
code and it can also
be done declaratively.

593
00:31:34,870 --> 00:31:37,510
I don't think there's an
example of that on here,

594
00:31:37,510 --> 00:31:42,415
but let's see, OnEventGoTo,

595
00:31:42,415 --> 00:31:46,300
there's a declarative way of
saying when the MakeCoffee,

596
00:31:46,300 --> 00:31:48,490
if we're in the ready State
and somebody presses,

597
00:31:48,490 --> 00:31:50,965
"The Make Coffee" button, then

598
00:31:50,965 --> 00:31:53,320
we can just go straight
to the MakeCoffee State.

599
00:31:53,320 --> 00:31:54,700
So this is something
that's completely

600
00:31:54,700 --> 00:31:56,245
handled by the Coyote runtime,

601
00:31:56,245 --> 00:31:58,780
we don't even have to
write any code to do

602
00:31:58,780 --> 00:32:01,690
that State transition
to making coffee,

603
00:32:01,690 --> 00:32:03,985
and then when we start making coffee,

604
00:32:03,985 --> 00:32:06,070
that's when the really
interesting stuff happens,

605
00:32:06,070 --> 00:32:07,105
we grind the beans,

606
00:32:07,105 --> 00:32:09,910
we go into GrindingBeans
State and so on and so forth.

607
00:32:09,910 --> 00:32:11,410
So you can see how
that StateMachine is

608
00:32:11,410 --> 00:32:15,115
progressing throughout
this code here.

609
00:32:15,115 --> 00:32:18,955
The sensors then is,

610
00:32:18,955 --> 00:32:22,330
this is called MockSensors because
this is not the real machine.

611
00:32:22,330 --> 00:32:25,270
Obviously, this is not the actual
firmware of the real machine.

612
00:32:25,270 --> 00:32:28,450
This is built just for testing.

613
00:32:28,450 --> 00:32:31,195
We have Monitors, which I'll
get into in a little bit,

614
00:32:31,195 --> 00:32:33,219
but we have the door sensor,

615
00:32:33,219 --> 00:32:36,310
we have the water tank,

616
00:32:36,310 --> 00:32:38,530
and these are all just simple Actors.

617
00:32:38,530 --> 00:32:40,390
These are simple
enough that it didn't

618
00:32:40,390 --> 00:32:42,100
need to use the StateMachine model,

619
00:32:42,100 --> 00:32:44,170
it can just be a simple Actor.

620
00:32:44,170 --> 00:32:48,985
So the water tank can register
a client that it can talk to.

621
00:32:48,985 --> 00:32:51,070
It can read the water level,

622
00:32:51,070 --> 00:32:52,615
as you saw earlier.

623
00:32:52,615 --> 00:32:54,490
It can read the water temperature,

624
00:32:54,490 --> 00:32:57,100
you can actually turn
on the water heater,

625
00:32:57,100 --> 00:32:58,930
and there's a timer concept.

626
00:32:58,930 --> 00:33:02,200
So Coyote Actors also support Timers,

627
00:33:02,200 --> 00:33:07,795
which is a frequent callback Event
that can happen automatically.

628
00:33:07,795 --> 00:33:09,940
Then you can pump the water

629
00:33:09,940 --> 00:33:11,740
to make a coffee and
so on and so forth.

630
00:33:11,740 --> 00:33:14,015
There's another Timer involved there.

631
00:33:14,015 --> 00:33:18,540
So this is an example of a mock
implementation of an Actor that's

632
00:33:18,540 --> 00:33:21,060
implementing the logic behind

633
00:33:21,060 --> 00:33:24,210
the sensors and the hardware
of the coffee machine.

634
00:33:24,210 --> 00:33:26,250
The CoffeeMachine
class then is more like

635
00:33:26,250 --> 00:33:28,000
the CPU of the coffee machine,

636
00:33:28,000 --> 00:33:29,320
it's the thing that
coordinates all that

637
00:33:29,320 --> 00:33:32,320
hardware and makes the
machine actually work.

638
00:33:32,320 --> 00:33:36,310
Now, up a level here we
have a Failover driver.

639
00:33:36,310 --> 00:33:38,200
So this sample is more

640
00:33:38,200 --> 00:33:40,300
than just showing you
how state machines work.

641
00:33:40,300 --> 00:33:43,310
This sample is going to do one
more really interesting thing.

642
00:33:43,310 --> 00:33:46,515
To test that our code is
ready for prime time,

643
00:33:46,515 --> 00:33:49,320
we're going to reboot
the coffee machine.

644
00:33:49,320 --> 00:33:51,720
So imagine if the
little tiny CPU inside

645
00:33:51,720 --> 00:33:52,950
the coffee machine glitched out and

646
00:33:52,950 --> 00:33:55,305
rebooted halfway through
making a coffee.

647
00:33:55,305 --> 00:33:58,440
What bad things could
happen with that?

648
00:33:58,440 --> 00:34:01,625
Obviously, if you're not careful
in how you write that code,

649
00:34:01,625 --> 00:34:03,685
it could do all kinds
of silly things.

650
00:34:03,685 --> 00:34:07,420
Then what we do is we have
some assertions in the code,

651
00:34:07,420 --> 00:34:10,435
things that we want to
verify, never happen.

652
00:34:10,435 --> 00:34:14,260
For example, do not turn on the
water heater if there's no water,

653
00:34:14,260 --> 00:34:16,630
bad things could happen, it
can burn down your house.

654
00:34:16,630 --> 00:34:18,250
Do not turn on

655
00:34:18,250 --> 00:34:20,965
the coffee grinder if there's
no beans in the hopper,

656
00:34:20,965 --> 00:34:23,590
that can ruin the grinder.

657
00:34:23,590 --> 00:34:26,815
Don't try to make a shot if
there's no water and so on.

658
00:34:26,815 --> 00:34:28,330
There's also a safety feature.

659
00:34:28,330 --> 00:34:29,860
If the door is opened,

660
00:34:29,860 --> 00:34:31,885
the machine has to not do anything,

661
00:34:31,885 --> 00:34:33,745
you don't want fingers
getting stuck in there.

662
00:34:33,745 --> 00:34:36,010
So these are safety asserts

663
00:34:36,010 --> 00:34:38,290
that you'll see throughout
the sample code and

664
00:34:38,290 --> 00:34:40,540
shows how Coyote can help ensure that

665
00:34:40,540 --> 00:34:43,210
these asserts are always
true during testing,

666
00:34:43,210 --> 00:34:44,980
even during failover testing.

667
00:34:44,980 --> 00:34:47,680
So we're going to boot
up one coffee machine,

668
00:34:47,680 --> 00:34:49,480
it's going to get halfway through
it's process

669
00:34:49,480 --> 00:34:51,430
and then we're going to
kill it, just like that,

670
00:34:51,430 --> 00:34:53,215
and then we're going to start
another coffee machine,

671
00:34:53,215 --> 00:34:56,140
and what this test is
proving is that the code is

672
00:34:56,140 --> 00:35:00,640
hardened to handle failover nicely.

673
00:35:00,640 --> 00:35:02,815
The new coffee machine,
when it boots up,

674
00:35:02,815 --> 00:35:06,520
needs to verify all
of the sensor states,

675
00:35:06,520 --> 00:35:07,840
relearn what's happening,

676
00:35:07,840 --> 00:35:10,460
and make sure it doesn't
do something silly.

677
00:35:12,210 --> 00:35:14,230
When you build this program,

678
00:35:14,230 --> 00:35:17,635
it's still just a very
simple console program,

679
00:35:17,635 --> 00:35:20,860
and we get this here,

680
00:35:20,860 --> 00:35:22,540
and there'll be a bunch
of print statements that

681
00:35:22,540 --> 00:35:24,550
show you what the coffee
machine is doing.

682
00:35:24,550 --> 00:35:28,580
If we run that over here,

683
00:35:29,790 --> 00:35:32,530
right off the bat is we can

684
00:35:32,530 --> 00:35:34,570
see that it detected
that the door was open,

685
00:35:34,570 --> 00:35:35,860
great, so the door was open,

686
00:35:35,860 --> 00:35:38,890
which we can see in
red, the mock sensors,

687
00:35:38,890 --> 00:35:40,360
because those are test classes,

688
00:35:40,360 --> 00:35:42,745
do actually initialize the
machine with random states.

689
00:35:42,745 --> 00:35:43,780
So the door sensor,

690
00:35:43,780 --> 00:35:46,090
it randomly chooses
to be open or not.

691
00:35:46,090 --> 00:35:49,720
The water levels are randomly set
and the temperatures are set,

692
00:35:49,720 --> 00:35:51,175
the coffee levels are random,

693
00:35:51,175 --> 00:35:53,620
and that also helps the testing of

694
00:35:53,620 --> 00:35:56,455
this program discover more
of these fault cases.

695
00:35:56,455 --> 00:36:02,155
So that was interesting. We hit
the error case right off the bat.

696
00:36:02,155 --> 00:36:05,305
This time it's off and making coffee.

697
00:36:05,305 --> 00:36:07,660
However, we started off with

698
00:36:07,660 --> 00:36:11,230
random water levels and coffee
levels that were very low.

699
00:36:11,230 --> 00:36:12,970
These are very low numbers.

700
00:36:12,970 --> 00:36:14,830
It did heat up that water,

701
00:36:14,830 --> 00:36:18,130
which is fun, and it
started making coffee.

702
00:36:18,130 --> 00:36:19,420
So it started grinding beans

703
00:36:19,420 --> 00:36:20,830
and started filling
up the porter filter,

704
00:36:20,830 --> 00:36:22,795
but then it ran out of coffee
beans halfway through.

705
00:36:22,795 --> 00:36:25,300
So automatically it
went to an error state,

706
00:36:25,300 --> 00:36:27,880
at that point, the
coffee machine is done,

707
00:36:27,880 --> 00:36:29,830
there's nothing more that you can

708
00:36:29,830 --> 00:36:31,690
do with this test without restarting

709
00:36:31,690 --> 00:36:35,650
the test until we manually
refill the coffee machine.

710
00:36:35,650 --> 00:36:37,450
Let's see if we can find
a run that actually

711
00:36:37,450 --> 00:36:39,430
goes all the way to making coffee.

712
00:36:39,430 --> 00:36:43,750
No, that one's empty and
this one looks good.

713
00:36:43,750 --> 00:36:45,670
It's got higher levels there,

714
00:36:45,670 --> 00:36:48,040
so it's making shots and it
makes the coffee, great,

715
00:36:48,040 --> 00:36:50,740
all the way to three shots completed.

716
00:36:50,740 --> 00:36:54,880
So the first round of running
that coffee machine worked.

717
00:36:54,880 --> 00:36:56,800
Now remember all the
events flying around

718
00:36:56,800 --> 00:36:58,690
between the coffee machine and

719
00:36:58,690 --> 00:37:02,260
those mock sensor hardware
objects are all asynchronous.

720
00:37:02,260 --> 00:37:05,300
So this is a very
asynchronous program.

721
00:37:05,310 --> 00:37:08,860
So it will keep running until
it runs out of resources.

722
00:37:08,860 --> 00:37:10,345
But the question now is,

723
00:37:10,345 --> 00:37:13,000
how can we test every
possible interleaving of all

724
00:37:13,000 --> 00:37:15,805
of those Events and see if
there are any bugs in the code.

725
00:37:15,805 --> 00:37:19,795
We actually did inject a bug in the
code and we haven't hit it yet.

726
00:37:19,795 --> 00:37:22,300
In fact, you can run it like
this all day long and you'll

727
00:37:22,300 --> 00:37:25,270
probably never hit the bug that
we've injected in the code.

728
00:37:25,270 --> 00:37:27,880
So again, we'll run

729
00:37:27,880 --> 00:37:31,480
this in the Coyote test
tool to see what happens.

730
00:37:31,480 --> 00:37:36,295
Coyote test tool has some more
options besides iterations.

731
00:37:36,295 --> 00:37:39,470
I can also tell it, "What
are the max steps?"

732
00:37:39,540 --> 00:37:43,180
So for each iteration
you can explore it,

733
00:37:43,180 --> 00:37:45,355
but what if your program is
just an infinite program?

734
00:37:45,355 --> 00:37:47,590
You have to tell it to
stop somewhere, otherwise,

735
00:37:47,590 --> 00:37:50,260
the Coyote test tool will
just get stuck in exploring

736
00:37:50,260 --> 00:37:53,365
an infinite state of transitions.

737
00:37:53,365 --> 00:37:55,450
So what you can do is
you can say max steps,

738
00:37:55,450 --> 00:37:57,115
and let's say max steps is 500.

739
00:37:57,115 --> 00:37:58,900
There's no point testing

740
00:37:58,900 --> 00:38:02,710
more than 500 events at a
time for each iteration.

741
00:38:02,710 --> 00:38:05,440
You can also use different
scheduling algorithms.

742
00:38:05,440 --> 00:38:08,125
So Coyote, remember I said that

743
00:38:08,125 --> 00:38:11,890
Microsoft Researchers built a bunch

744
00:38:11,890 --> 00:38:13,540
of different search algorithms,

745
00:38:13,540 --> 00:38:14,860
and you can actually specify

746
00:38:14,860 --> 00:38:17,020
the search algorithm that
you want to use in a test,

747
00:38:17,020 --> 00:38:18,490
and this is called PCT.

748
00:38:18,490 --> 00:38:20,950
There's a lot more
documentation on that online,

749
00:38:20,950 --> 00:38:23,575
what that means, but I'll
go ahead and run that.

750
00:38:23,575 --> 00:38:25,795
So here it is setting up everything,

751
00:38:25,795 --> 00:38:27,040
iteration 1, 2, 3,

752
00:38:27,040 --> 00:38:28,735
4, and it found a bug.

753
00:38:28,735 --> 00:38:32,020
All right, surprise, surprise, I know,
we put it in on purpose.

754
00:38:32,020 --> 00:38:34,580
Let's take a look at the log file,

755
00:38:34,830 --> 00:38:37,870
and now this is more interesting.

756
00:38:37,870 --> 00:38:39,835
This is a real system, this
is not just Hello World,

757
00:38:39,835 --> 00:38:42,745
and so what we see now
as I page down here

758
00:38:42,745 --> 00:38:47,875
is 600 events before
we found the bug,

759
00:38:47,875 --> 00:38:50,980
and this was an assert
that triggered that said,

760
00:38:50,980 --> 00:38:52,420
"Please do not turn on
the grinder if there's

761
00:38:52,420 --> 00:38:54,010
no beans in the hopper."

762
00:38:54,010 --> 00:38:56,350
So with this failover experiment

763
00:38:56,350 --> 00:38:58,390
where we killed one machine,
started another machine,

764
00:38:58,390 --> 00:39:00,100
we're making coffee
all throughout this,

765
00:39:00,100 --> 00:39:02,590
we actually found a bug where it

766
00:39:02,590 --> 00:39:05,695
did try to turn on the grinder
when there were no beans.

767
00:39:05,695 --> 00:39:07,990
So there's definitely a bug in here.

768
00:39:07,990 --> 00:39:13,160
So the fun part of this exercise
then is to try to find that bug.

769
00:39:13,530 --> 00:39:17,210
I'll let you do that
in your own time.

770
00:39:17,760 --> 00:39:20,440
The other thing you can do with

771
00:39:20,440 --> 00:39:26,350
this test is you can ask for graph.

772
00:39:26,350 --> 00:39:28,375
Now I'm going to ask for graph of

773
00:39:28,375 --> 00:39:31,550
just the one iteration
that contained the bug

774
00:39:31,550 --> 00:39:35,070
and because of all of that
declarative state machinery

775
00:39:35,070 --> 00:39:38,415
around States and Events that
can be received and so on,

776
00:39:38,415 --> 00:39:40,980
there's a very cool feature
that's provided by Coyote

777
00:39:40,980 --> 00:39:43,740
which is producing a DGML diagram.

778
00:39:43,740 --> 00:39:48,235
DGML can be visualized
using Visual Studio.

779
00:39:48,235 --> 00:39:50,830
So here we go. This is

780
00:39:50,830 --> 00:39:53,770
a visualization of all the States
and State transitions that happened.

781
00:39:53,770 --> 00:39:57,010
I'm going to press, "Ctrl A" to
see everything that happened here.

782
00:39:57,010 --> 00:39:59,680
All of these links that are
connecting these nodes are

783
00:39:59,680 --> 00:40:03,430
messages that flowed across
these actors in State machines.

784
00:40:03,430 --> 00:40:06,805
You can see that a coffee
machine was created here,

785
00:40:06,805 --> 00:40:10,300
number 5, and it went all
the way through making,

786
00:40:10,300 --> 00:40:11,860
grinding, making shots,
and cleaning up.

787
00:40:11,860 --> 00:40:15,235
So this actually completed the
full iteration of making coffee.

788
00:40:15,235 --> 00:40:18,580
Then it was halted by
the failover driver.

789
00:40:18,580 --> 00:40:20,470
Remember we said we're going
to kill the coffee machines,

790
00:40:20,470 --> 00:40:23,800
here we've killed the coffee
machine and we create a new one.

791
00:40:23,800 --> 00:40:25,570
The new coffee machines
started up and

792
00:40:25,570 --> 00:40:27,190
went all the way through
to grinding beans,

793
00:40:27,190 --> 00:40:28,990
where it hit the assert that said,

794
00:40:28,990 --> 00:40:30,640
"Hey, hang on, there's
no beans in the hopper."

795
00:40:30,640 --> 00:40:32,860
So that's the bug.

796
00:40:32,860 --> 00:40:34,090
It should never have gone that far,

797
00:40:34,090 --> 00:40:35,500
it should have got to check sensors,

798
00:40:35,500 --> 00:40:36,730
and check sensors
should have said, "Hey,

799
00:40:36,730 --> 00:40:38,455
there's no coffee beans,
so what happened?"

800
00:40:38,455 --> 00:40:41,560
But this helps us visualize
what's going on here.

801
00:40:41,560 --> 00:40:44,530
In fact, the diagram animation
that I showed you on

802
00:40:44,530 --> 00:40:51,080
the webpage with the raft protocol
was built from these diagrams.

803
00:40:52,260 --> 00:40:55,270
So this is also a super useful way to

804
00:40:55,270 --> 00:40:57,910
just look at the design of
your program to communicate

805
00:40:57,910 --> 00:41:00,310
that design to other
people on the team and

806
00:41:00,310 --> 00:41:03,445
to visually see what's going
on in a complex system,

807
00:41:03,445 --> 00:41:05,350
which can also be very useful.

808
00:41:05,350 --> 00:41:08,200
So you can see now that Coyote
is more than a test tool.

809
00:41:08,200 --> 00:41:10,090
It's a test tool that integrates

810
00:41:10,090 --> 00:41:12,040
with your development
process by providing

811
00:41:12,040 --> 00:41:16,300
frameworks and declarative ways
of declaring states and so on,

812
00:41:16,300 --> 00:41:17,860
and it integrates with your design

813
00:41:17,860 --> 00:41:19,060
process in the sense that you can

814
00:41:19,060 --> 00:41:22,700
now see what your program is
doing and reason about it.

815
00:41:25,140 --> 00:41:28,510
I glossed over quickly in
that state machine example,

816
00:41:28,510 --> 00:41:30,370
there is also a Monitor.

817
00:41:30,370 --> 00:41:35,380
The Monitor is a type of
state machine that is

818
00:41:35,380 --> 00:41:40,150
a passive listener in a sense
that a Monitor can receive

819
00:41:40,150 --> 00:41:42,010
Events but it shouldn't
be sending Events to

820
00:41:42,010 --> 00:41:44,950
other parts of the system,
so it's just there.

821
00:41:44,950 --> 00:41:48,340
Oftentimes you'll run Monitors
only in test time and not

822
00:41:48,340 --> 00:41:49,630
a production time and
if you don't want

823
00:41:49,630 --> 00:41:51,865
the overhead of monitoring stuff.

824
00:41:51,865 --> 00:41:55,180
The Monitor is something
that Coyote also supports

825
00:41:55,180 --> 00:41:58,180
some really cool concepts
including a LivenessMonitor,

826
00:41:58,180 --> 00:42:00,110
and let me show you
the code for that.

827
00:42:00,110 --> 00:42:02,640
We have a LivenessMonitor
in the coffee machine.

828
00:42:02,640 --> 00:42:03,750
What does that mean?
What are we looking

829
00:42:03,750 --> 00:42:05,190
for with a LivenessMonitor?

830
00:42:05,190 --> 00:42:07,470
A LivenessMonitor is something that

831
00:42:07,470 --> 00:42:10,520
has Cold States and Hot States.

832
00:42:10,520 --> 00:42:12,310
These are two custom
attributes that are

833
00:42:12,310 --> 00:42:14,095
only available on monitors.

834
00:42:14,095 --> 00:42:16,840
Coyote will make sure

835
00:42:16,840 --> 00:42:20,005
that your Monitor doesn't
get stuck in the Hot State.

836
00:42:20,005 --> 00:42:23,050
What this means, the way this can
be used in the coffee machine,

837
00:42:23,050 --> 00:42:25,420
is we're trying to verify

838
00:42:25,420 --> 00:42:28,030
that the coffee machine
always gets the job done.

839
00:42:28,030 --> 00:42:30,550
With async programs,
where you can easily get

840
00:42:30,550 --> 00:42:32,680
stuck in these circular Events storms,

841
00:42:32,680 --> 00:42:34,480
in this case, sends an
Event, which sends an Event,

842
00:42:34,480 --> 00:42:37,675
which sends an Event and you
get this big ladder effect,

843
00:42:37,675 --> 00:42:39,355
it's sometimes hard to

844
00:42:39,355 --> 00:42:41,710
prove that your program's ever
actually going to finish.

845
00:42:41,710 --> 00:42:44,110
I've actually seen this
problem happen with

846
00:42:44,110 --> 00:42:46,540
real commercial large systems where

847
00:42:46,540 --> 00:42:49,405
they get stuck in Events storms
and then never finish the job.

848
00:42:49,405 --> 00:42:50,800
So it's a hard problem.

849
00:42:50,800 --> 00:42:53,620
So the LivenessMonitor is a
tool that you can use with

850
00:42:53,620 --> 00:42:57,010
Coyote to verify that your
machine always finishes the job.

851
00:42:57,010 --> 00:42:58,540
It has to either make

852
00:42:58,540 --> 00:43:01,780
the coffee or report an error
that it needs refilling,

853
00:43:01,780 --> 00:43:03,280
but it should never get stuck in

854
00:43:03,280 --> 00:43:06,130
some intermediate state of just
going round and round and round.

855
00:43:06,130 --> 00:43:10,165
Coyote will actually verify
this at test time and

856
00:43:10,165 --> 00:43:12,024
it has an algorithm that determines

857
00:43:12,024 --> 00:43:14,140
if it's spent too much
time in a Hot State,

858
00:43:14,140 --> 00:43:16,330
Coyote will raise an assert
automatically saying,

859
00:43:16,330 --> 00:43:18,730
''Hey, you've got a problem.''

860
00:43:18,730 --> 00:43:21,850
The door safety Monitor is a
different kind of Monitor.

861
00:43:21,850 --> 00:43:23,260
It's not a LivenessMonitor,

862
00:43:23,260 --> 00:43:25,120
so it doesn't use
Hot and Cold States.

863
00:43:25,120 --> 00:43:29,560
Instead it's just a
global thing that's

864
00:43:29,560 --> 00:43:32,170
monitoring BusyEvents from

865
00:43:32,170 --> 00:43:34,840
the coffee machine and
the DoorOpenEvent.

866
00:43:34,840 --> 00:43:36,400
So it remembers if there's

867
00:43:36,400 --> 00:43:39,520
a DoorOpenEvent that we
should go to the Error State.

868
00:43:39,520 --> 00:43:41,020
When we're in the Error State,

869
00:43:41,020 --> 00:43:43,300
if we ever get any indication

870
00:43:43,300 --> 00:43:45,625
from the coffee machine
that is doing something,

871
00:43:45,625 --> 00:43:47,455
then it shouldn't be,
and that's an error.

872
00:43:47,455 --> 00:43:49,180
So we can assert right off the bat.

873
00:43:49,180 --> 00:43:51,520
If the coffee machine started doing

874
00:43:51,520 --> 00:43:55,135
something while the door was
open, this should never happen.

875
00:43:55,135 --> 00:44:00,290
So that's another way of
writing Monitors using Coyote.

876
00:44:04,410 --> 00:44:08,380
You can run them at test time or
some people actually do choose to

877
00:44:08,380 --> 00:44:12,520
run Monitors in production
as well. All right.

878
00:44:12,520 --> 00:44:16,180
So now, let's move it up
a level to something even

879
00:44:16,180 --> 00:44:19,960
more real and this is the original
example that I showed you,

880
00:44:19,960 --> 00:44:25,100
which is the implementation
of the Raft cluster protocol.

881
00:44:25,770 --> 00:44:29,320
Raft is often used for
fault tolerant clusters.

882
00:44:29,320 --> 00:44:33,160
So what we've done in this
example called CloudMessaging,

883
00:44:33,160 --> 00:44:37,240
is we've provided four
projects that use Coyote.

884
00:44:37,240 --> 00:44:40,465
Since we're on this page,

885
00:44:40,465 --> 00:44:43,540
I'll take the opportunity to show
a classic state machine here,

886
00:44:43,540 --> 00:44:45,415
all implemented with States.

887
00:44:45,415 --> 00:44:49,120
So now with a really clear
glance at this code,

888
00:44:49,120 --> 00:44:50,680
you can see the kind of

889
00:44:50,680 --> 00:44:52,600
state machinery that's
going on in this class.

890
00:44:52,600 --> 00:44:53,770
You don't have to reverse

891
00:44:53,770 --> 00:44:55,690
engineer by looking at all
the member variables and

892
00:44:55,690 --> 00:44:59,020
how those member variables are
sprinkled around all of your code.

893
00:44:59,020 --> 00:45:02,360
It's very clear declaration
of a state machine.

894
00:45:02,370 --> 00:45:06,520
So the four projects in the solution,

895
00:45:06,520 --> 00:45:08,530
the Raft project over here,

896
00:45:08,530 --> 00:45:12,070
is just a C# library
that uses Coyote,

897
00:45:12,070 --> 00:45:13,870
doesn't know anything about Azure,

898
00:45:13,870 --> 00:45:19,225
it's a pure implementation
of the Raft server protocol,

899
00:45:19,225 --> 00:45:21,190
so that's what this class is.

900
00:45:21,190 --> 00:45:23,885
The Raft server is a StateMachine.

901
00:45:23,885 --> 00:45:26,190
But again, like I said, this
doesn't know anything about Azure,

902
00:45:26,190 --> 00:45:28,335
it sends messages and

903
00:45:28,335 --> 00:45:31,365
receives messages and
implements the Raft protocol,

904
00:45:31,365 --> 00:45:33,855
you can see there's quite
a lot of code here.

905
00:45:33,855 --> 00:45:36,780
There's a really great website online

906
00:45:36,780 --> 00:45:38,220
that explains the Raft protocol,

907
00:45:38,220 --> 00:45:40,605
how it works, it's quite intricate.

908
00:45:40,605 --> 00:45:43,500
Of course, if you're building
a fault tolerant cluster

909
00:45:43,500 --> 00:45:45,060
of services, you really
want to know that

910
00:45:45,060 --> 00:45:46,950
that code is correct, so that's

911
00:45:46,950 --> 00:45:50,070
why it's really important
to test this with Coyote.

912
00:45:50,070 --> 00:45:52,680
How do servers talk to other servers?

913
00:45:52,680 --> 00:45:55,575
So in a true distributed system,

914
00:45:55,575 --> 00:45:57,690
you're going to have
some sort of message bus,

915
00:45:57,690 --> 00:45:59,580
you're going to have
some messaging system

916
00:45:59,580 --> 00:46:02,310
that send messages across machines.

917
00:46:02,310 --> 00:46:03,630
Now, Coyote is not in

918
00:46:03,630 --> 00:46:05,910
the business of providing
a messaging platform.

919
00:46:05,910 --> 00:46:07,960
Coyote is not one of those things,

920
00:46:07,960 --> 00:46:09,700
it doesn't compete
with service bus and

921
00:46:09,700 --> 00:46:11,800
compete with any messaging system.

922
00:46:11,800 --> 00:46:14,215
Coyote is just an
abstraction on top of that.

923
00:46:14,215 --> 00:46:16,750
So what we've done here,

924
00:46:16,750 --> 00:46:20,235
is we've modeled the cluster concept,

925
00:46:20,235 --> 00:46:22,200
the Pub-sub concept, if you like.

926
00:46:22,200 --> 00:46:23,910
So a server can send a message to

927
00:46:23,910 --> 00:46:26,910
all the other servers
is a Pub-sub concept.

928
00:46:26,910 --> 00:46:31,150
We've modeled that as a
state machine using Coyote.

929
00:46:31,150 --> 00:46:32,620
So we've created this
cluster manager,

930
00:46:32,620 --> 00:46:36,715
but this is going to be an abstract
class with no implementations.

931
00:46:36,715 --> 00:46:40,015
You can see here that it doesn't
actually implement anything.

932
00:46:40,015 --> 00:46:42,670
It's expected that either
your test will implement

933
00:46:42,670 --> 00:46:45,535
something or your true
Azure deployment will plug

934
00:46:45,535 --> 00:46:51,775
in here how to broadcast a request
across that Pub-sub system.

935
00:46:51,775 --> 00:46:55,435
In the Raft Azure project,

936
00:46:55,435 --> 00:46:58,345
you'll actually see an Azure
Cluster Manager that's

937
00:46:58,345 --> 00:47:01,990
implemented using the service
bus topic client API.

938
00:47:01,990 --> 00:47:04,360
So if you're familiar
with Azure Service Bus,

939
00:47:04,360 --> 00:47:06,265
it provides a concept of Topics.

940
00:47:06,265 --> 00:47:10,150
Topics are Pub-sub concept where
you have a Topic client that can

941
00:47:10,150 --> 00:47:14,139
send messages and you
have a Topic receiver,

942
00:47:14,139 --> 00:47:16,210
a message receiver from

943
00:47:16,210 --> 00:47:19,240
the service bus that can
receive those Pub-sub messages.

944
00:47:19,240 --> 00:47:23,605
So this is how we've plugged
into the Azure Service Bus.

945
00:47:23,605 --> 00:47:26,005
When we receive messages,

946
00:47:26,005 --> 00:47:28,120
we can see we have to parse JSON and

947
00:47:28,120 --> 00:47:30,745
all that stuff Coyote
doesn't care about.

948
00:47:30,745 --> 00:47:33,445
What really matters is at some point,

949
00:47:33,445 --> 00:47:37,735
you get the Coyote Actor runtime
and you call SendEvent.

950
00:47:37,735 --> 00:47:40,135
So there we've gone from SendEvent,

951
00:47:40,135 --> 00:47:41,695
out to a Pub-sub system,

952
00:47:41,695 --> 00:47:44,275
the Pub-sub system has
brought that message back in,

953
00:47:44,275 --> 00:47:47,350
and then we push it back into
the Coyote world, if you like.

954
00:47:47,350 --> 00:47:51,025
So we've plugged Azure back
into this Coyote world.

955
00:47:51,025 --> 00:47:53,170
But we've kept at a
very clean separation.

956
00:47:53,170 --> 00:47:55,900
The reason why that clean
separation is good,

957
00:47:55,900 --> 00:47:58,990
is when you get to the
mocking version of

958
00:47:58,990 --> 00:48:03,550
this program where we
want to test this thing.

959
00:48:03,550 --> 00:48:06,070
So the mock version has

960
00:48:06,070 --> 00:48:08,770
a mock client that sends
Events to the servers,

961
00:48:08,770 --> 00:48:13,495
so this is how we request work
to be done by that cluster.

962
00:48:13,495 --> 00:48:15,670
We have a mock cluster manager

963
00:48:15,670 --> 00:48:17,440
that doesn't know about
Azure Service Bus,

964
00:48:17,440 --> 00:48:24,235
so broadcast is a very simple
for-loop over a list of servers,

965
00:48:24,235 --> 00:48:27,475
where that list of servers
is a bunch of ActorIDs.

966
00:48:27,475 --> 00:48:29,410
So it's a for-loop, just send it to

967
00:48:29,410 --> 00:48:31,765
all the other guys except for us,

968
00:48:31,765 --> 00:48:35,240
the guy who is sending this request.

969
00:48:35,670 --> 00:48:39,790
So the mock implementation
of cluster manager all runs

970
00:48:39,790 --> 00:48:43,870
locally in the same process
even or if you run it locally,

971
00:48:43,870 --> 00:48:45,790
you can run it in multiple processes.

972
00:48:45,790 --> 00:48:48,205
But this one is

973
00:48:48,205 --> 00:48:51,625
actually going to run the
whole test in one process,

974
00:48:51,625 --> 00:48:54,400
which means that Coyote can
run really, really fast.

975
00:48:54,400 --> 00:48:56,755
When Coyote is testing
this Raft protocol,

976
00:48:56,755 --> 00:48:59,635
it doesn't have to wait
for service bus events,

977
00:48:59,635 --> 00:49:04,885
it can run thousands of times
faster in memory on one machine.

978
00:49:04,885 --> 00:49:06,850
It's also super convenient
for a developer

979
00:49:06,850 --> 00:49:08,830
to be able to test
all of their code in

980
00:49:08,830 --> 00:49:10,765
isolation on one machine

981
00:49:10,765 --> 00:49:14,090
before they try to push
it into production.

982
00:49:14,460 --> 00:49:23,640
So let's go ahead and build that.

983
00:49:23,640 --> 00:49:26,740
I won't run the Azure
version because that needs

984
00:49:26,740 --> 00:49:29,140
a Service Bus account
setup and all that stuff.

985
00:49:29,140 --> 00:49:30,820
You can see there's
a setup script that

986
00:49:30,820 --> 00:49:32,575
will do that in the tutorial.

987
00:49:32,575 --> 00:49:34,210
You're certainly welcome
to go ahead and run that,

988
00:49:34,210 --> 00:49:37,375
prove that it works with
Azure Service Bus, provide

989
00:49:37,375 --> 00:49:39,370
connection strings on a
command line and so forth.

990
00:49:39,370 --> 00:49:40,630
But what I'm going to run is

991
00:49:40,630 --> 00:49:45,860
the Mock version of this and
see if it can find any bugs.

992
00:49:46,140 --> 00:49:49,720
This is actually a picture
that after I ran this,

993
00:49:49,720 --> 00:49:52,810
I was using the same
graphing capability

994
00:49:52,810 --> 00:49:56,635
to look at what happened in the
state machine at test time.

995
00:49:56,635 --> 00:49:59,620
So here you can see this is

996
00:49:59,620 --> 00:50:02,590
actually a different type of graph
that's called a coverage graph,

997
00:50:02,590 --> 00:50:05,080
so it doesn't show all
five servers, instead,

998
00:50:05,080 --> 00:50:07,224
it collapses each instance

999
00:50:07,224 --> 00:50:10,270
into one group to just
show you a code coverage.

1000
00:50:10,270 --> 00:50:13,750
So it's showing you what are all
the things that happened across

1001
00:50:13,750 --> 00:50:16,960
all 100 or 1,000
iterations for testing

1002
00:50:16,960 --> 00:50:21,775
this thing and I'll show you
how that works right here.

1003
00:50:21,775 --> 00:50:28,090
So I'm going to run the same Coyote
test tool, except this time,

1004
00:50:28,090 --> 00:50:30,410
I'm going to use .NET47,

1005
00:50:32,190 --> 00:50:35,080
we can also support .NET Core,

1006
00:50:35,080 --> 00:50:37,060
which means Coyote is
also a cross-platform,

1007
00:50:37,060 --> 00:50:40,520
you can run that on any system
that has .NET Core.

1008
00:50:41,010 --> 00:50:48,110
I'm going to test the
bin\net47\Raft.Mocking.dll.

1009
00:50:48,120 --> 00:50:51,970
Now, I'm going to test
1,000 iterations, well,

1010
00:50:51,970 --> 00:50:54,535
let's do 100 iterations
with Max steps

1011
00:50:54,535 --> 00:50:57,730
of 200 steps per iteration
and I'm going to

1012
00:50:57,730 --> 00:51:04,090
request that coverage graph
and that's activity coverage.

1013
00:51:04,090 --> 00:51:05,920
So this is different
from code coverage,

1014
00:51:05,920 --> 00:51:07,870
it's a higher-level
concept of coverage,

1015
00:51:07,870 --> 00:51:11,500
which is at that Event level
where all the Events that were

1016
00:51:11,500 --> 00:51:13,270
declared Sent and Received by

1017
00:51:13,270 --> 00:51:15,280
all the various places that
said they could receive Events,

1018
00:51:15,280 --> 00:51:17,875
so it's like an Event coverage graph.

1019
00:51:17,875 --> 00:51:20,500
So it went ahead and
it ran 100 iterations,

1020
00:51:20,500 --> 00:51:22,930
didn't find any bugs in this
case, which is expected,

1021
00:51:22,930 --> 00:51:26,035
because we didn't put
any bugs in it yet.

1022
00:51:26,035 --> 00:51:29,455
There's your diagram and

1023
00:51:29,455 --> 00:51:32,545
very similar to the
version we saw before.

1024
00:51:32,545 --> 00:51:35,300
Let me get rid of that.

1025
00:51:38,690 --> 00:51:43,800
"Ctrl A" I can see Events were
sent across these things,

1026
00:51:43,800 --> 00:51:45,675
so there's an Event here,

1027
00:51:45,675 --> 00:51:47,670
a state machine timer

1028
00:51:47,670 --> 00:51:51,710
sent a timer-lapsed event,
the cluster manager

1029
00:51:51,710 --> 00:51:53,395
sent Events, and so on.

1030
00:51:53,395 --> 00:51:56,050
So the implementation of the
Raft protocol does, in fact,

1031
00:51:56,050 --> 00:51:59,050
involve these four states and you
can read about what those states

1032
00:51:59,050 --> 00:52:02,785
mean on the webpage
description of this tutorial,

1033
00:52:02,785 --> 00:52:05,500
but you can see it's actually
reaching all the states.

1034
00:52:05,500 --> 00:52:07,120
Most importantly, for this test,

1035
00:52:07,120 --> 00:52:09,280
we want to see that
one of the servers at

1036
00:52:09,280 --> 00:52:11,440
some point reached
the leader state and

1037
00:52:11,440 --> 00:52:13,450
this can also be a
Liveness problem if

1038
00:52:13,450 --> 00:52:15,790
no server has ever
reached the leader state,

1039
00:52:15,790 --> 00:52:17,110
then it means they're just jostling

1040
00:52:17,110 --> 00:52:18,400
and jostling and jostling for leader,

1041
00:52:18,400 --> 00:52:19,690
but nobody's actually getting it.

1042
00:52:19,690 --> 00:52:22,480
That would be a Liveness
problem with your cluster,

1043
00:52:22,480 --> 00:52:24,220
so it's great to see that during

1044
00:52:24,220 --> 00:52:28,100
this test the leader state
was achieved. All right.

1045
00:52:31,410 --> 00:52:35,950
So remember, Coyote can help
you with non-determinism.

1046
00:52:35,950 --> 00:52:41,860
So we have a fourth
project in that solution,

1047
00:52:41,860 --> 00:52:44,335
which is called Raft Non-determinism,

1048
00:52:44,335 --> 00:52:45,970
where we can actually start to

1049
00:52:45,970 --> 00:52:47,920
model some
non-deterministic behavior.

1050
00:52:47,920 --> 00:52:51,160
So oftentimes, when you
build a mock using Coyote,

1051
00:52:51,160 --> 00:52:53,920
what you want to do is capture
some of the weird behaviors of

1052
00:52:53,920 --> 00:52:57,670
some external system that you
have to deal with. In this case,

1053
00:52:57,670 --> 00:52:59,725
we have modeled a situation where

1054
00:52:59,725 --> 00:53:01,540
the non-deterministic
behavior is that

1055
00:53:01,540 --> 00:53:03,595
somewhere in our messaging system,

1056
00:53:03,595 --> 00:53:05,650
whatever messaging system that is,

1057
00:53:05,650 --> 00:53:08,275
we end up getting duplicate Events.

1058
00:53:08,275 --> 00:53:10,240
Another thing you might model is

1059
00:53:10,240 --> 00:53:12,520
Events get lost and
never get delivered.

1060
00:53:12,520 --> 00:53:14,920
But in this case,
we're going to model

1061
00:53:14,920 --> 00:53:18,640
the non-deterministic problem
that we're struggling with,

1062
00:53:18,640 --> 00:53:22,795
is our system can't handle it
when we get duplicate Events.

1063
00:53:22,795 --> 00:53:26,995
So let's take a look at
that code just quickly.

1064
00:53:26,995 --> 00:53:28,240
The way we do that in

1065
00:53:28,240 --> 00:53:32,530
Raft.Nondeterminism is
we inject a special

1066
00:53:32,530 --> 00:53:34,945
implementation of
the cluster manager,

1067
00:53:34,945 --> 00:53:39,250
where that cluster
manager is going to

1068
00:53:39,250 --> 00:53:41,230
randomly decide based on

1069
00:53:41,230 --> 00:53:44,110
this random boolean to
send an Event twice,

1070
00:53:44,110 --> 00:53:46,090
so we get duplicates.

1071
00:53:46,090 --> 00:53:49,300
What's that going to do
to the server and is

1072
00:53:49,300 --> 00:53:52,915
the implementation
or the Raft protocol

1073
00:53:52,915 --> 00:53:56,780
going to be able to handle
that without any problems.

1074
00:53:57,150 --> 00:54:05,420
We can run Raft.Nondeterminism,
just like before,

1075
00:54:05,610 --> 00:54:11,095
like that, and it's going to
go ahead and search for bugs.

1076
00:54:11,095 --> 00:54:15,920
We've asked for 100 iterations
and we'll see what happens.

1077
00:54:19,950 --> 00:54:23,830
Didn't find any bugs,
found zero bugs,

1078
00:54:23,830 --> 00:54:27,220
so what I happen to
know is that this bug

1079
00:54:27,220 --> 00:54:30,715
is particularly hard to reproduce.

1080
00:54:30,715 --> 00:54:34,315
In other words, the
servers are quite good,

1081
00:54:34,315 --> 00:54:37,165
the server implementation
is really good.

1082
00:54:37,165 --> 00:54:39,160
But I guarantee you,

1083
00:54:39,160 --> 00:54:40,870
there is a bug in there, so now I'm

1084
00:54:40,870 --> 00:54:42,580
going to show you another
feature of Coyote,

1085
00:54:42,580 --> 00:54:46,000
which is that you can also ask

1086
00:54:46,000 --> 00:54:54,445
for a whole collection of
different scheduling algorithms,

1087
00:54:54,445 --> 00:54:58,180
remember those search
algorithms portfolio.

1088
00:54:58,180 --> 00:55:00,684
So this is telling Coyote,

1089
00:55:00,684 --> 00:55:03,790
don't just use one
scheduling algorithm,

1090
00:55:03,790 --> 00:55:06,580
but throw lots of

1091
00:55:06,580 --> 00:55:09,640
different scheduling algorithms
at this problem and, even better,

1092
00:55:09,640 --> 00:55:15,654
let's run eight tests at once in
parallel, in different processes.

1093
00:55:15,654 --> 00:55:18,130
So this is going to fire
up eight processes on

1094
00:55:18,130 --> 00:55:21,400
my box and it's probably going
to kill my poor little laptop,

1095
00:55:21,400 --> 00:55:26,500
let's see what happens, and it's going

1096
00:55:26,500 --> 00:55:28,210
to give each one of those processes

1097
00:55:28,210 --> 00:55:30,370
a different random
scheduling algorithm

1098
00:55:30,370 --> 00:55:31,870
and then we're going to search.

1099
00:55:31,870 --> 00:55:34,270
So here we can see it
launching all five of

1100
00:55:34,270 --> 00:55:38,365
those processes and
it starts firing up,

1101
00:55:38,365 --> 00:55:40,630
it's got probabilistic,
it's got random,

1102
00:55:40,630 --> 00:55:42,730
fair PCT, so there's

1103
00:55:42,730 --> 00:55:46,015
your random selection of
search algorithms if you like.

1104
00:55:46,015 --> 00:55:47,950
Off it goes, running, running,

1105
00:55:47,950 --> 00:55:54,220
running and it found no bugs.

1106
00:55:54,220 --> 00:55:55,585
But the cool thing is,

1107
00:55:55,585 --> 00:55:57,325
with these really hard bugs,

1108
00:55:57,325 --> 00:55:59,560
I can increase the
max steps and I can

1109
00:55:59,560 --> 00:56:02,305
increase the number of iterations.

1110
00:56:02,305 --> 00:56:04,120
Coyote is doing all
the hard work for me,

1111
00:56:04,120 --> 00:56:07,990
I can run a million iterations
and go have a coffee

1112
00:56:07,990 --> 00:56:10,510
and then come back and I got
the bug. Then I can tell

1113
00:56:10,510 --> 00:56:13,880
my manager how wonderful I am
that I can find bugs like that.

1114
00:56:14,610 --> 00:56:20,410
It'll help your career. I'll let

1115
00:56:20,410 --> 00:56:22,090
that run off in the background
and we'll come back and check

1116
00:56:22,090 --> 00:56:24,860
it later and see if it found a bug.

1117
00:56:27,090 --> 00:56:29,815
So that's the end of my talk

1118
00:56:29,815 --> 00:56:34,075
and what we really want
is your input on this.

1119
00:56:34,075 --> 00:56:36,340
I think you'll agree
so far that Coyote is

1120
00:56:36,340 --> 00:56:38,290
a powerful tool that can help you

1121
00:56:38,290 --> 00:56:41,020
grapple with concurrency
in non-determinism.

1122
00:56:41,020 --> 00:56:42,670
It's available now both as

1123
00:56:42,670 --> 00:56:47,120
a NuGet package and a
source code on GitHub.

1124
00:56:47,550 --> 00:56:50,440
If you go up there and
take a look at the website,

1125
00:56:50,440 --> 00:56:55,900
you'll see that there are more
examples as well. Like this one,

1126
00:56:55,900 --> 00:56:59,350
robots. So if that's your fun topic,

1127
00:56:59,350 --> 00:57:02,260
there's a really fun tutorial
here that will show you how

1128
00:57:02,260 --> 00:57:05,785
we've used Coyote to help a
robot navigate around a room.

1129
00:57:05,785 --> 00:57:08,905
So that thing was running
in the background and

1130
00:57:08,905 --> 00:57:12,745
it found a bug and we can
see that there's a log file.

1131
00:57:12,745 --> 00:57:18,115
This log file now is huge,

1132
00:57:18,115 --> 00:57:23,500
it contains 6,700 Events and

1133
00:57:23,500 --> 00:57:25,780
it found a bug and the
bug is that there was

1134
00:57:25,780 --> 00:57:28,960
more than one leader elected
in the cluster at one time,

1135
00:57:28,960 --> 00:57:31,270
which breaks the protocol.

1136
00:57:31,270 --> 00:57:34,225
You can't have a
fault-tolerant cluster if

1137
00:57:34,225 --> 00:57:36,625
two servers are competing
for the same job.

1138
00:57:36,625 --> 00:57:39,310
So there you see it,

1139
00:57:39,310 --> 00:57:43,030
found a bug and we also see
the replayable schedule.

1140
00:57:43,030 --> 00:57:45,160
So again, now in a real system,

1141
00:57:45,160 --> 00:57:46,870
the replay feature becomes huge.

1142
00:57:46,870 --> 00:57:49,015
So it took a long time
to find this bug

1143
00:57:49,015 --> 00:57:53,080
but when I replay this using
that replace schedule,

1144
00:57:53,080 --> 00:57:55,790
using the replay command,

1145
00:57:56,130 --> 00:57:59,980
it'll only have to run
those 6,000 messages.

1146
00:57:59,980 --> 00:58:02,770
So it should be a lot quicker
than it was the first time,

1147
00:58:02,770 --> 00:58:05,290
so it took 14 seconds the first time,

1148
00:58:05,290 --> 00:58:07,135
the replay should be a lot quicker.

1149
00:58:07,135 --> 00:58:10,510
Of course, with the replay I
can put that in the debugger,

1150
00:58:10,510 --> 00:58:11,770
I can put breakpoints everywhere,

1151
00:58:11,770 --> 00:58:13,630
I can step through it
as slowly as I want,

1152
00:58:13,630 --> 00:58:15,295
I don't need to care about

1153
00:58:15,295 --> 00:58:17,350
that interfering with the
timing of everything.

1154
00:58:17,350 --> 00:58:19,570
It will reproduce the bug 100 percent

1155
00:58:19,570 --> 00:58:23,395
guaranteed and you can
find the bug and fix it.

1156
00:58:23,395 --> 00:58:27,130
We'll try to answer your questions
and issues as quickly as we

1157
00:58:27,130 --> 00:58:30,475
can if you post them up on
the GitHub issues list.

1158
00:58:30,475 --> 00:58:32,455
We also have a Gitter account

1159
00:58:32,455 --> 00:58:34,750
there for Coyote and
the stack overflow tag.

1160
00:58:34,750 --> 00:58:37,240
So feel free, post
your questions there

1161
00:58:37,240 --> 00:58:43,120
and we look forward to hearing
from you. Thank you very much.
